<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEON SPECTER: FLOW</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@300;700&display=swap');
        body { background: #020408; margin: 0; overflow: hidden; font-family: 'Montserrat', sans-serif; touch-action: none; height: 100vh; display: flex; flex-direction: column; }
        
        .hud { height: 60px; display: none; justify-content: space-around; align-items: center; color: #a0f0ff; background: rgba(5, 10, 20, 0.9); border-bottom: 1px solid #ffffff10; letter-spacing: 2px; z-index: 10; }
        .stat-group { display: flex; flex-direction: column; align-items: center; }
        .label { font-size: 8px; color: #5080a0; margin-bottom: 2px; text-transform: uppercase; }
        .val { font-size: 14px; font-weight: 700; text-shadow: 0 0 8px #00f0ff; }

        #game-container { flex: 1; display: flex; justify-content: center; align-items: center; background: #000; position: relative; overflow: hidden; }
        canvas { border-radius: 4px; }

        .overlay { position: absolute; top:0; left:0; width: 100%; height:100%; display: none; flex-direction: column; justify-content: center; align-items: center; color: #fff; z-index: 20; text-align: center; }
        #menu-overlay { background: #020408; display: flex; }
        #pause-overlay { background: #000; z-index: 40; }
        #death-overlay { background: rgba(20, 0, 0, 0.9); z-index: 30; }
        
        #controls-area { height: 220px; background: #020408; border-top: 1px solid #ffffff05; display: flex; flex-direction: column; align-items: center; padding-top: 15px; }
        
        .button-bar { width: 100%; display: none; justify-content: space-evenly; margin-bottom: 20px; }
        .ui-btn { width: 42%; padding: 12px; background: rgba(255,255,255,0.05); border: 1px solid #444; color: #fff; font-family: 'Montserrat'; font-size: 11px; font-weight: 700; border-radius: 25px; text-transform: uppercase; cursor: pointer; letter-spacing: 1px; transition: 0.2s; }
        .ui-btn:active { transform: scale(0.95); background: rgba(255,255,255,0.1); }
        .primary-btn { border-color: #00f0ff; box-shadow: 0 0 15px rgba(0, 240, 255, 0.2); }

        #joy-base { width: 100px; height: 100px; background: rgba(255,255,255,0.03); border: 2px solid rgba(255,255,255,0.1); border-radius: 50%; position: relative; visibility: hidden; }
        #joy-stick { position: absolute; top: 25px; left: 25px; width: 50px; height: 50px; background: linear-gradient(135deg, #00f0ff, #0070ff); border-radius: 50%; box-shadow: 0 0 30px rgba(0, 240, 255, 0.4); pointer-events: none; }
    </style>
</head>
<body>
    <div class="hud" id="hud">
        <div class="stat-group"><span class="label">Phase</span><span class="val" id="lvl">1</span></div>
        <div class="stat-group"><span class="label">Health</span><span class="val" id="hp">100</span></div>
        <div class="stat-group"><span class="label">Theme</span><span class="val" id="theme-name">ZEN</span></div>
    </div>

    <div id="game-container">
        <canvas id="canvas"></canvas>
        <div id="menu-overlay" class="overlay">
            <h1 style="letter-spacing: 12px; font-weight: 300; margin-bottom: 5px;">NEON SPECTER</h1>
            <p style="color: #00f0ff; font-size: 9px; margin-bottom: 40px; letter-spacing: 5px;">ENTER THE FLOW</p>
            <button class="ui-btn primary-btn" id="continue-btn" onclick="startGame(true)" style="display: none; margin-bottom: 15px;">Continue Phase 1</button>
            <button class="ui-btn" onclick="startGame(false)" style="margin-bottom: 15px;">New Run</button>
            <button class="ui-btn" onclick="resetProgress()" style="color: #ff4444; border-color: #552222; font-size: 9px; width: 30%;">Clear Data</button>
        </div>
        <div id="pause-overlay" class="overlay">
            <h1 style="letter-spacing: 10px; font-weight: 300; color: #00f0ff;">SENSORS OFFLINE</h1>
            <button class="ui-btn primary-btn" onclick="togglePause()" style="margin-bottom: 15px;">Re-Link</button>
            <button class="ui-btn" onclick="quitToMenu()">Abort Mission</button>
        </div>
        <div id="death-overlay" class="overlay">
            <h1 style="letter-spacing: 5px; color: #ff4444; margin-bottom: 5px;">হা!হা! বলদ পারে না</h1>
            <p id="death-stat" style="color: #5080a0; font-size: 10px; margin-bottom: 25px; text-transform: uppercase;"></p>
            <button class="ui-btn" onclick="retryLevel()" style="background: #ff4444; border: none; width: 60%; margin-bottom: 15px;">Play Again</button>
            <button class="ui-btn" onclick="quitToMenu()" style="width: 60%;">Main Menu</button>
        </div>
    </div>

    <div id="controls-area">
        <div class="button-bar" id="game-buttons">
            <button class="ui-btn" onclick="toggleCamera()" id="camBtn">Cam: Normal</button>
            <button class="ui-btn" onclick="togglePause()" id="pauseBtn">Pause</button>
        </div>
        <div id="joy-base"><div id="joy-stick"></div></div>
    </div>

<script>
const themes = [
    { name: 'ZEN', wall: '#0a1220', accent: '#00f0ff', bg: '#020408' },
    { name: 'KANTHA', wall: '#4a1e1e', accent: '#ffcc00', bg: '#2a0a0a' },
    { name: 'STREET', wall: '#222', accent: '#00ff00', bg: '#111' },
    { name: 'WARZONE', wall: '#3a3d35', accent: '#ff5500', bg: '#1a1c18' },
    { name: 'VAPOR', wall: '#2d004d', accent: '#ff00ff', bg: '#0d001a' },
    { name: 'MIDNIGHT', wall: '#001a33', accent: '#3399ff', bg: '#000810' },
    { name: 'LAVA', wall: '#4d0000', accent: '#ff3300', bg: '#1a0000' },
    { name: 'CYBER', wall: '#1a0033', accent: '#00ffff', bg: '#0a001a' }
];

let canvas = document.getElementById('canvas'), ctx = canvas.getContext('2d');
let base = document.getElementById('joy-base'), stick = document.getElementById('joy-stick');
let audioCtx, flowGain, flowFilter, ambOsc, ambGain;
let isPaused = false, isDying = false, gameActive = false, isFollowCam = false;
let cols, rows, tile, maze = [], keys = [], trails = [], deathParticles = [], blackHoles = [];
let cameraZoom = 1, currentThemeIdx = 0;
let player = { x: 1.5, y: 1.5 }, enemy = { x: 0, y: 0, speed: 0.01 };
let state = { score: 1, hp: 100, keysFound: 0, frame: 0 };

window.onload = checkSave;

function checkSave() {
    const saved = localStorage.getItem('neon_specter_phase');
    const btn = document.getElementById('continue-btn');
    if(saved && parseInt(saved) > 1) {
        btn.style.display = 'block';
        btn.innerText = `Continue Phase ${saved}`;
    } else { btn.style.display = 'none'; }
}

function setUIVisibility(active) {
    document.getElementById('hud').style.display = active ? 'flex' : 'none';
    document.getElementById('game-buttons').style.display = active ? 'flex' : 'none';
    document.getElementById('joy-base').style.visibility = active ? 'visible' : 'hidden';
}

function initAudio() {
    if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    
    // Resume context (required for many browsers to start audio after user click)
    if (audioCtx.state === 'suspended') {
        audioCtx.resume();
    }

    if (!flowGain) {
        const bufferSize = 2 * audioCtx.sampleRate, noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate), output = noiseBuffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) output[i] = Math.random() * 2 - 1;
        let noiseNode = audioCtx.createBufferSource();
        noiseNode.buffer = noiseBuffer; noiseNode.loop = true;
        flowFilter = audioCtx.createBiquadFilter();
        flowFilter.type = 'lowpass'; 
        flowGain = audioCtx.createGain(); flowGain.gain.value = 0;
        noiseNode.connect(flowFilter); flowFilter.connect(flowGain); flowGain.connect(audioCtx.destination);
        noiseNode.start();
    }

    if (!ambOsc) {
        ambOsc = audioCtx.createOscillator();
        ambOsc.type = 'sine';
        ambGain = audioCtx.createGain();
        ambGain.gain.value = 0;
        ambOsc.connect(ambGain);
        ambGain.connect(audioCtx.destination);
        ambOsc.start();
    }
}

function playSFX(type) {
    if(!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    osc.connect(g); g.connect(audioCtx.destination);
    const now = audioCtx.currentTime;

    if(type === 'hurt') {
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(100, now);
        osc.frequency.exponentialRampToValueAtTime(30, now + 0.2);
        g.gain.setValueAtTime(0.2, now);
        g.gain.linearRampToValueAtTime(0, now + 0.2);
        osc.start(); osc.stop(now + 0.2);
    } else if(type === 'complete') {
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(300, now);
        osc.frequency.exponentialRampToValueAtTime(900, now + 0.4);
        g.gain.setValueAtTime(0.15, now);
        g.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
        osc.start(); osc.stop(now + 0.4);
    } else if(type === 'key') {
        osc.type = 'sine';
        osc.frequency.setValueAtTime(800 + (state.keysFound * 150), now);
        g.gain.setValueAtTime(0.1, now);
        g.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
        osc.start(); osc.stop(now + 0.2);
    } else if(type === 'teleport') {
        osc.type = 'square';
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.exponentialRampToValueAtTime(10, now + 0.5);
        g.gain.setValueAtTime(0.1, now);
        g.gain.linearRampToValueAtTime(0, now + 0.5);
        osc.start(); osc.stop(now + 0.5);
    }
}

function startGame(useSave) {
    initAudio(); // Initialize audio on user interaction
    if(useSave) { state.score = parseInt(localStorage.getItem('neon_specter_phase')) || 1; }
    else { state.score = 1; }
    state.hp = 100; state.keysFound = 0;
    gameActive = true; isPaused = false; isDying = false;
    document.getElementById('menu-overlay').style.display = 'none';
    setUIVisibility(true);
    buildMap();
}

function buildMap() {
    currentThemeIdx = (state.score - 1) % themes.length;
    document.getElementById('theme-name').innerText = themes[currentThemeIdx].name;
    document.getElementById('lvl').innerText = state.score;
    document.getElementById('hp').innerText = Math.ceil(state.hp);
    saveProgress();

    if(ambGain) {
        ambGain.gain.setTargetAtTime(0.05, audioCtx.currentTime, 1);
        ambOsc.frequency.setTargetAtTime(40 + (state.score * 1.5), audioCtx.currentTime, 1);
    }
    
    cols = Math.min(21 + (state.score * 2), 55); rows = cols;
    tile = Math.min(window.innerWidth * 0.95 / cols, (window.innerHeight - 340) / rows);
    canvas.width = cols * tile; canvas.height = rows * tile;
    
    maze = Array.from({length: rows}, () => Array(cols).fill(1));
    let stack = [[1, 1]]; maze[1][1] = 0;
    while(stack.length) {
        let [cx, cy] = stack[stack.length-1];
        let n = [[0,2],[0,-2],[2,0],[-2,0]].map(([dx,dy]) => [cx+dx, cy+dy])
                 .filter(([nx,ny]) => nx>0 && nx<cols-1 && ny>0 && ny<rows-1 && maze[ny][nx]);
        if(n.length) {
            let [nx, ny] = n[Math.floor(Math.random()*n.length)];
            maze[ny][nx] = 0; maze[cy+(ny-cy)/2][cx+(nx-cx)/2] = 0; stack.push([nx,ny]);
        } else stack.pop();
    }
    keys = []; while(keys.length < 3) {
        let kx = Math.floor(Math.random()*cols), ky = Math.floor(Math.random()*rows);
        if(maze[ky][kx] === 0 && (kx > 5 || ky > 5)) keys.push({x: kx+0.5, y: ky+0.5, active: true});
    }

    blackHoles = [];
    if(state.score >= 21) {
        let count = 4;
        while(blackHoles.length < count) {
            let bx = Math.floor(Math.random()*cols), by = Math.floor(Math.random()*rows);
            if(maze[by][bx] === 0 && Math.hypot(bx - 1.5, by - 1.5) > 10) {
                blackHoles.push({x: bx + 0.5, y: by + 0.5});
            }
        }
    }

    player = { x: 1.5, y: 1.5 };
    enemy = { x: cols - 1.5, y: rows - 1.5, speed: Math.max(0.008, 0.02 * Math.pow(0.98, state.score - 1)) };
}

function quitToMenu() {
    gameActive = false; isPaused = false;
    document.getElementById('pause-overlay').style.display = 'none';
    document.getElementById('death-overlay').style.display = 'none';
    document.getElementById('menu-overlay').style.display = 'flex';
    setUIVisibility(false);
    if(ambGain) ambGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.5);
    checkSave();
}

function toggleCamera() {
    isFollowCam = !isFollowCam;
    document.getElementById('camBtn').innerText = isFollowCam ? "Cam: Follow" : "Cam: Normal";
}

function saveProgress() { localStorage.setItem('neon_specter_phase', state.score); }
function resetProgress() { if(confirm("Reset progress?")) { localStorage.removeItem('neon_specter_phase'); location.reload(); }}
function togglePause() { if(!gameActive || isDying) return; isPaused = !isPaused; document.getElementById('pause-overlay').style.display = isPaused ? 'flex' : 'none'; }
function retryLevel() { isDying = false; state.hp = 100; state.keysFound = 0; deathParticles = []; cameraZoom = 1; document.getElementById('death-overlay').style.display = 'none'; buildMap(); }

let input = { x: 0, y: 0, d: 0 };
base.addEventListener('touchstart', (e) => { if(gameActive) handleMove(e); });
base.addEventListener('touchmove', e => { if(gameActive && !isPaused && !isDying){ e.preventDefault(); handleMove(e); } });
base.addEventListener('touchend', () => { input = {x:0, y:0, d:0}; stick.style.transform = 'none'; });

function handleMove(e) {
    let r = base.getBoundingClientRect(), dx = e.touches[0].clientX - (r.left + r.width/2), dy = e.touches[0].clientY - (r.top + r.height/2);
    let d = Math.min(40, Math.hypot(dx, dy)), a = Math.atan2(dy, dx);
    stick.style.transform = `translate(${Math.cos(a)*d}px, ${Math.sin(a)*d}px)`;
    input.x = (Math.cos(a) * (d/40)) * 0.22; input.y = (Math.sin(a) * (d/40)) * 0.22;
    input.d = d / 40;
}

function update() {
    if(!gameActive || isPaused || isDying) {
        if(flowGain) flowGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.2);
        return;
    }
    state.frame++;
    
    // Audio Modulation
    if(flowGain && flowFilter) {
        let isBHActive = Math.sin(state.frame * 0.05) > 0;
        let distToBH = 100;
        blackHoles.forEach(bh => {
            let d = Math.hypot(player.x - bh.x, player.y - bh.y);
            if(d < distToBH) distToBH = d;
        });
        
        // Distort sound if near active black hole
        let bhDistortion = (isBHActive && distToBH < 3) ? (3 - distToBH) * 500 : 0;
        flowGain.gain.setTargetAtTime(0.05 + (input.d * 0.25), audioCtx.currentTime, 0.1);
        flowFilter.frequency.setTargetAtTime(300 + (input.d * 1500) - bhDistortion, audioCtx.currentTime, 0.1);
    }

    let nx = player.x + input.x, ny = player.y + input.y, b = 0.2;
    if(maze[Math.floor(player.y)][Math.floor(nx + (input.x > 0 ? b : -b))] === 0) player.x = nx;
    if(maze[Math.floor(ny + (input.y > 0 ? b : -b))][Math.floor(player.x)] === 0) player.y = ny;
    
    if(state.frame % 5 === 0) trails.push({x: player.x, y: player.y, a: 0.4});
    trails.forEach((t, i) => { t.a -= 0.02; if(t.a <= 0) trails.splice(i,1); });
    
    keys.forEach(k => { if(k.active && Math.hypot(player.x - k.x, player.y - k.y) < 0.6) { k.active = false; state.keysFound++; playSFX('key'); }});

    let isBHActive = Math.sin(state.frame * 0.05) > 0;
    if(isBHActive) {
        blackHoles.forEach(bh => {
            if(Math.hypot(player.x - bh.x, player.y - bh.y) < 0.5) {
                player.x = 1.5; player.y = 1.5; playSFX('teleport');
            }
        });
    }

    enemy.x += (player.x - enemy.x) * enemy.speed; enemy.y += (player.y - enemy.y) * enemy.speed;
    
    if(Math.hypot(player.x - enemy.x, player.y - enemy.y) < 0.6) {
        state.hp -= 1.0; 
        document.getElementById('hp').innerText = Math.max(0, Math.ceil(state.hp));
        if(state.frame % 12 === 0) playSFX('hurt');
        if(state.hp <= 0) { 
            isDying = true; playSFX('hurt');
            for(let i=0; i<40; i++) deathParticles.push({x: player.x, y: player.y, vx: (Math.random()-0.5)*0.1, vy: (Math.random()-0.5)*0.1, life: 1.0});
            setTimeout(() => { document.getElementById('death-overlay').style.display = 'flex'; }, 1200);
        }
    }
    if(state.keysFound >= 3 && Math.hypot(player.x - (cols-1.5), player.y - (rows-1.5)) < 0.6) {
        playSFX('complete'); state.score++; state.hp = Math.min(100, state.hp + 20); state.keysFound = 0; buildMap();
    }
}

function drawGameObjects(isMini) {
    const theme = themes[currentThemeIdx] || themes[0];
    const s = isMini ? 0.3 : 1;
    for(let y=0; y<rows; y++) {
        for(let x=0; x<cols; x++) if(maze[y][x]) {
            ctx.fillStyle = theme.wall; ctx.fillRect(x*tile*s, y*tile*s, tile*s, tile*s);
        }
    }

    let pulse = (Math.sin(state.frame * 0.05) + 1) / 2;
    blackHoles.forEach(bh => {
        if(!isMini) {
            ctx.shadowBlur = 20 * pulse;
            ctx.shadowColor = "#8000ff";
        }
        ctx.fillStyle = `rgba(0, 0, 0, ${0.7 + (pulse * 0.3)})`;
        ctx.beginPath();
        ctx.arc(bh.x*tile*s, bh.y*tile*s, (tile/2.2)*s, 0, 7);
        ctx.fill();
        ctx.strokeStyle = `rgba(128, 0, 255, ${pulse})`;
        ctx.lineWidth = 3;
        ctx.stroke();
    });
    ctx.shadowBlur = 0;

    ctx.fillStyle = state.keysFound >= 3 ? '#fff' : 'rgba(255,255,255,0.1)'; 
    ctx.fillRect(((cols-2)*tile+tile/4)*s, ((rows-2)*tile+tile/4)*s, (tile/2)*s, (tile/2)*s);
    keys.forEach(k => { if(k.active) { 
        if(!isMini) { ctx.shadowBlur = 15; ctx.shadowColor = theme.accent; }
        ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(k.x*tile*s, k.y*tile*s, (tile/4)*s, 0, 7); ctx.fill(); 
    }});
    trails.forEach(t => { ctx.fillStyle = theme.accent; ctx.globalAlpha = t.a; ctx.beginPath(); ctx.arc(t.x*tile*s, t.y*tile*s, (tile/6)*s, 0, 7); ctx.fill(); });
    ctx.globalAlpha = 1; 
    if(!isDying) { 
        if(!isMini) { ctx.shadowBlur = 15; ctx.shadowColor = theme.accent; }
        ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(player.x*tile*s, player.y*tile*s, (tile/4)*s, 0, 7); ctx.fill(); 
    }
    deathParticles.forEach((p, i) => {
        p.x += p.vx; p.y += p.vy; p.life -= 0.02; ctx.fillStyle = theme.accent; ctx.globalAlpha = p.life;
        ctx.fillRect(p.x * tile * s, p.y * tile * s, 4*s, 4*s);
        if(p.life <= 0) deathParticles.splice(i, 1);
    });
    ctx.globalAlpha = 1; ctx.fillStyle = '#f00'; ctx.beginPath(); ctx.arc(enemy.x*tile*s, enemy.y*tile*s, (tile/3)*s, 0, 7); ctx.fill();
    ctx.shadowBlur = 0;
}

function draw() {
    if (isPaused) { requestAnimationFrame(draw); return; }
    const theme = themes[currentThemeIdx] || themes[0];
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = theme.bg; ctx.fillRect(0,0,canvas.width, canvas.height);
    ctx.save();
    if(isDying) {
        cameraZoom = Math.min(cameraZoom + 0.03, 3);
        ctx.translate(canvas.width/2, canvas.height/2); ctx.scale(cameraZoom, cameraZoom);
        ctx.translate(-player.x * tile, -player.y * tile); drawGameObjects(false);
    } else if(isFollowCam) {
        ctx.translate(canvas.width/2, canvas.height/2); ctx.scale(4.5, 4.5);
        ctx.translate(-player.x * tile, -player.y * tile); drawGameObjects(false);
    } else { drawGameObjects(false); }
    ctx.restore();
    if(gameActive && state.keysFound > 0 && !isDying && !isPaused) {
        ctx.save(); ctx.globalCompositeOperation = 'destination-in';
        let r = state.keysFound === 1 ? 200 : state.keysFound === 2 ? 120 : 70;
        let centerX = isFollowCam ? canvas.width/2 : player.x * tile;
        let centerY = isFollowCam ? canvas.height/2 : player.y * tile;
        let grad = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, r);
        grad.addColorStop(0, 'rgba(0,0,0,1)'); grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grad; ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.restore();
    }
    if(isFollowCam && !isDying && !isPaused) {
        ctx.save(); ctx.translate(10, 10); ctx.fillStyle = "rgba(0,0,0,0.5)"; ctx.strokeStyle = theme.accent;
        const ms = 0.2; ctx.fillRect(0, 0, cols*tile*ms, rows*tile*ms); ctx.strokeRect(0, 0, cols*tile*ms, rows*tile*ms);
        drawGameObjects(true); ctx.restore();
    }
    update(); requestAnimationFrame(draw);
}
draw();
</script>
</body>
</html>

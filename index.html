<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEON SPECTER: FLOW</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@300;700&display=swap');
        body { background: #05080a; margin: 0; overflow: hidden; font-family: 'Montserrat', sans-serif; touch-action: none; height: 100vh; display: flex; flex-direction: column; }
        
        .hud { height: 60px; display: none; justify-content: space-around; align-items: center; color: #a0f0ff; background: rgba(10, 20, 35, 0.95); border-bottom: 2px solid #00f0ff30; letter-spacing: 2px; z-index: 10; box-shadow: 0 5px 20px rgba(0,0,0,0.5); }
        .stat-group { display: flex; flex-direction: column; align-items: center; }
        .label { font-size: 8px; color: #5080a0; margin-bottom: 2px; text-transform: uppercase; }
        .val { font-size: 14px; font-weight: 700; text-shadow: 0 0 8px #00f0ff; }

        #game-container { flex: 1; display: flex; justify-content: center; align-items: center; background: #000; position: relative; overflow: hidden; }
        canvas { border-radius: 4px; }

        .overlay { position: absolute; top:0; left:0; width: 100%; height:100%; display: none; flex-direction: column; justify-content: center; align-items: center; color: #fff; z-index: 20; text-align: center; }
        
        #menu-overlay { background: radial-gradient(circle, #0a1018 0%, #020408 100%); display: flex; }
        .glitch { font-size: 42px; font-weight: 300; letter-spacing: 12px; position: relative; text-shadow: 0.05em 0 0 #00fffc, -0.03em -0.04em 0 #fc00ff, 0.025em 0.04em 0 #fffc00; animation: glitch 725ms infinite; }
        @keyframes glitch {
            0% { text-shadow: 0.05em 0 0 #00fffc, -0.03em -0.04em 0 #fc00ff, 0.025em 0.04em 0 #fffc00; }
            15% { text-shadow: 0.05em 0 0 #00fffc, -0.03em -0.04em 0 #fc00ff, 0.025em 0.04em 0 #fffc00; }
            16% { text-shadow: -0.05em -0.025em 0 #00fffc, 0.025em 0.035em 0 #fc00ff, -0.05em -0.05em 0 #fffc00; }
            49% { text-shadow: -0.05em -0.025em 0 #00fffc, 0.025em 0.035em 0 #fc00ff, -0.05em -0.05em 0 #fffc00; }
            50% { text-shadow: 0.03em 0.035em 0 #00fffc, 0.03em 0 0 #fc00ff, 0.06em -0.035em 0 #fffc00; }
            99% { text-shadow: 0.03em 0.035em 0 #00fffc, 0.03em 0 0 #fc00ff, 0.06em -0.035em 0 #fffc00; }
            100% { text-shadow: -0.03em 0 0 #00fffc, -0.03em -0.03em 0 #fc00ff, -0.05em -0.05em 0 #fffc00; }
        }

        #pause-overlay { background: rgba(0,0,0,0.85); backdrop-filter: blur(5px); z-index: 40; }
        #death-overlay { background: rgba(40, 0, 0, 0.95); z-index: 30; }
        
        #controls-area { height: 220px; background: #05080a; border-top: 2px solid #00f0ff15; display: flex; flex-direction: column; align-items: center; padding-top: 15px; }
        
        .button-bar { width: 100%; display: none; justify-content: space-evenly; margin-bottom: 20px; }
        .ui-btn { width: 42%; padding: 12px; background: rgba(255,255,255,0.05); border: 1px solid #444; color: #fff; font-family: 'Montserrat'; font-size: 11px; font-weight: 700; border-radius: 4px; text-transform: uppercase; cursor: pointer; letter-spacing: 1px; transition: 0.2s; }
        .ui-btn:active { transform: scale(0.95); background: rgba(0, 240, 255, 0.2); }
        .primary-btn { border-color: #00f0ff; background: rgba(0, 240, 255, 0.1); box-shadow: 0 0 15px rgba(0, 240, 255, 0.3); }

        #joy-base { width: 110px; height: 110px; background: rgba(255,255,255,0.05); border: 2px solid rgba(0, 240, 255, 0.2); border-radius: 50%; position: relative; visibility: hidden; }
        #joy-stick { position: absolute; top: 30px; left: 30px; width: 50px; height: 50px; background: #00f0ff; border-radius: 50%; box-shadow: 0 0 20px #00f0ff; pointer-events: none; }
    </style>
</head>
<body>
    <div class="hud" id="hud">
        <div class="stat-group"><span class="label">Phase</span><span class="val" id="lvl">1</span></div>
        <div class="stat-group"><span class="label">Health</span><span class="val" id="hp">100</span></div>
        <div class="stat-group"><span class="label">Theme</span><span class="val" id="theme-name">ZEN</span></div>
    </div>

    <div id="game-container">
        <canvas id="canvas"></canvas>
        <div id="menu-overlay" class="overlay">
            <h1 class="glitch">SPECTER</h1>
            <p style="color: #00f0ff; font-size: 10px; margin-bottom: 40px; letter-spacing: 8px; opacity: 0.8;">[ FLOW_PROTOCOL_V2 ]</p>
            <button class="ui-btn primary-btn" id="continue-btn" onclick="startGame(true)" style="display: none; margin-bottom: 15px;">Continue Phase 1</button>
            <button class="ui-btn" onclick="startGame(false)" style="margin-bottom: 15px; border-color: #fff;">New Run</button>
            <button class="ui-btn" onclick="resetProgress()" style="color: #ff4444; border-color: #552222; font-size: 9px; width: 30%;">Wipe Core</button>
        </div>
        <div id="pause-overlay" class="overlay">
            <h1 style="letter-spacing: 10px; font-weight: 300; color: #00f0ff;">SENSORS OFFLINE</h1>
            <button class="ui-btn primary-btn" onclick="togglePause()" style="margin-bottom: 15px;">Re-Link</button>
            <button class="ui-btn" onclick="quitToMenu()">Abort Mission</button>
        </div>
        <div id="death-overlay" class="overlay">
            <h1 style="letter-spacing: 5px; color: #ff4444; margin-bottom: 5px;">হা!হা! বলদ পারে না</h1>
            <p id="death-stat" style="color: #5080a0; font-size: 10px; margin-bottom: 25px; text-transform: uppercase;"></p>
            <button class="ui-btn" onclick="retryLevel()" style="background: #ff4444; border: none; width: 60%; margin-bottom: 15px;">Play Again</button>
            <button class="ui-btn" onclick="quitToMenu()" style="width: 60%;">Main Menu</button>
        </div>
    </div>

    <div id="controls-area">
        <div class="button-bar" id="game-buttons">
            <button class="ui-btn" onclick="toggleCamera()" id="camBtn">Cam: Normal</button>
            <button class="ui-btn" onclick="togglePause()" id="pauseBtn">Pause</button>
        </div>
        <div id="joy-base"><div id="joy-stick"></div></div>
    </div>

<script>
const themes = [
    { name: 'ZEN', wall: '#152540', accent: '#00f0ff', bg: '#050a14' },
    { name: 'KANTHA', wall: '#6e2d2d', accent: '#ffcc00', bg: '#2a0a0a' },
    { name: 'STREET', wall: '#444', accent: '#00ff00', bg: '#111' },
    { name: 'WARZONE', wall: '#5a5d55', accent: '#ff5500', bg: '#1a1c18' },
    { name: 'VAPOR', wall: '#4d008d', accent: '#ff00ff', bg: '#0d001a' },
    { name: 'MIDNIGHT', wall: '#002a53', accent: '#3399ff', bg: '#000810' },
    { name: 'LAVA', wall: '#8d0000', accent: '#ff3300', bg: '#1a0000' },
    { name: 'CYBER', wall: '#2a0063', accent: '#00ffff', bg: '#0a001a' }
];

let canvas = document.getElementById('canvas'), ctx = canvas.getContext('2d');
let base = document.getElementById('joy-base'), stick = document.getElementById('joy-stick');
let audioCtx, flowGain, flowFilter, ambOsc, ambGain;
let isPaused = false, isDying = false, gameActive = false, isFollowCam = false;
let cols, rows, tile, maze = [], keys = [], trails = [], deathParticles = [], blackHoles = [];
let cameraZoom = 1, currentThemeIdx = 0;
let player = { x: 1.5, y: 1.5 }, enemy = { x: 0, y: 0, speed: 0.01 };
let state = { score: 1, hp: 100, keysFound: 0, frame: 0 };

let input = { x: 0, y: 0, d: 0 };
base.addEventListener('touchstart', (e) => { if(gameActive) handleMove(e); });
base.addEventListener('touchmove', e => { if(gameActive && !isPaused && !isDying){ e.preventDefault(); handleMove(e); } });
base.addEventListener('touchend', () => { input = {x:0, y:0, d:0}; stick.style.transform = 'none'; });

function handleMove(e) {
    let r = base.getBoundingClientRect(), dx = e.touches[0].clientX - (r.left + r.width/2), dy = e.touches[0].clientY - (r.top + r.height/2);
    let d = Math.min(45, Math.hypot(dx, dy)), a = Math.atan2(dy, dx);
    stick.style.transform = `translate(${Math.cos(a)*d}px, ${Math.sin(a)*d}px)`;
    input.x = (Math.cos(a) * (d/45)) * 0.22; input.y = (Math.sin(a) * (d/45)) * 0.22;
    input.d = d / 45;
}

window.onload = checkSave;

function checkSave() {
    const saved = localStorage.getItem('neon_specter_phase');
    const btn = document.getElementById('continue-btn');
    if(saved && parseInt(saved) > 1) {
        btn.style.display = 'block';
        btn.innerText = `Continue Phase ${saved}`;
    } else { btn.style.display = 'none'; }
}

function setUIVisibility(active) {
    document.getElementById('hud').style.display = active ? 'flex' : 'none';
    document.getElementById('game-buttons').style.display = active ? 'flex' : 'none';
    document.getElementById('joy-base').style.visibility = active ? 'visible' : 'hidden';
}

function initAudio() {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === 'suspended') audioCtx.resume();
    if (!flowGain) {
        const bufferSize = 2 * audioCtx.sampleRate, noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate), output = noiseBuffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) output[i] = Math.random() * 2 - 1;
        let noiseNode = audioCtx.createBufferSource();
        noiseNode.buffer = noiseBuffer; noiseNode.loop = true;
        flowFilter = audioCtx.createBiquadFilter();
        flowFilter.type = 'lowpass'; 
        flowGain = audioCtx.createGain(); flowGain.gain.value = 0;
        noiseNode.connect(flowFilter); flowFilter.connect(flowGain); flowGain.connect(audioCtx.destination);
        noiseNode.start();
    }
    if (!ambOsc) {
        ambOsc = audioCtx.createOscillator();
        ambOsc.type = 'sine';
        ambGain = audioCtx.createGain();
        ambGain.gain.value = 0;
        ambOsc.connect(ambGain);
        ambGain.connect(audioCtx.destination);
        ambOsc.start();
    }
}

function playSFX(type) {
    if(!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    osc.connect(g); g.connect(audioCtx.destination);
    const now = audioCtx.currentTime;
    if(type === 'hurt') {
        osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, now);
        osc.frequency.exponentialRampToValueAtTime(30, now + 0.2);
        g.gain.setValueAtTime(0.2, now); g.gain.linearRampToValueAtTime(0, now + 0.2);
        osc.start(); osc.stop(now + 0.2);
    } else if(type === 'complete') {
        osc.type = 'triangle'; osc.frequency.setValueAtTime(300, now);
        osc.frequency.exponentialRampToValueAtTime(900, now + 0.4);
        g.gain.setValueAtTime(0.15, now); g.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
        osc.start(); osc.stop(now + 0.4);
    } else if(type === 'key') {
        osc.type = 'sine'; osc.frequency.setValueAtTime(800 + (state.keysFound * 150), now);
        g.gain.setValueAtTime(0.1, now); g.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
        osc.start(); osc.stop(now + 0.2);
    }
}

function startGame(useSave) {
    initAudio();
    if(useSave) { state.score = parseInt(localStorage.getItem('neon_specter_phase')) || 1; }
    else { state.score = 1; }
    state.hp = 100; state.keysFound = 0;
    gameActive = true; isPaused = false; isDying = false;
    document.getElementById('menu-overlay').style.display = 'none';
    setUIVisibility(true);
    buildMap();
}

function buildMap() {
    currentThemeIdx = (state.score - 1) % themes.length;
    document.getElementById('theme-name').innerText = themes[currentThemeIdx].name;
    document.getElementById('lvl').innerText = state.score;
    document.getElementById('hp').innerText = Math.ceil(state.hp);
    saveProgress();
    if(ambGain) {
        ambGain.gain.setTargetAtTime(0.05, audioCtx.currentTime, 1);
        ambOsc.frequency.setTargetAtTime(40 + (state.score * 1.5), audioCtx.currentTime, 1);
    }
    cols = Math.min(21 + (state.score * 2), 55); rows = cols;
    tile = Math.min(window.innerWidth * 0.95 / cols, (window.innerHeight - 340) / rows);
    canvas.width = cols * tile; canvas.height = rows * tile;
    maze = Array.from({length: rows}, () => Array(cols).fill(1));
    let stack = [[1, 1]]; maze[1][1] = 0;
    while(stack.length) {
        let [cx, cy] = stack[stack.length-1];
        let n = [[0,2],[0,-2],[2,0],[-2,0]].map(([dx,dy]) => [cx+dx, cy+dy])
                 .filter(([nx,ny]) => nx>0 && nx<cols-1 && ny>0 && ny<rows-1 && maze[ny][nx]);
        if(n.length) {
            let [nx, ny] = n[Math.floor(Math.random()*n.length)];
            maze[ny][nx] = 0; maze[cy+(ny-cy)/2][cx+(nx-cx)/2] = 0; stack.push([nx,ny]);
        } else stack.pop();
    }
    keys = []; while(keys.length < 3) {
        let kx = Math.floor(Math.random()*cols), ky = Math.floor(Math.random()*rows);
        if(maze[ky][kx] === 0 && (kx > 5 || ky > 5)) keys.push({x: kx+0.5, y: ky+0.5, active: true});
    }
    blackHoles = [];
    if(state.score >= 21) {
        let count = 4;
        while(blackHoles.length < count) {
            let bx = Math.floor(Math.random()*cols), by = Math.floor(Math.random()*rows);
            if(maze[by][bx] === 0 && Math.hypot(bx - 1.5, by - 1.5) > 10) blackHoles.push({x: bx + 0.5, y: by + 0.5});
        }
    }
    player = { x: 1.5, y: 1.5 };
    enemy = { x: cols - 1.5, y: rows - 1.5, speed: Math.max(0.008, 0.02 * Math.pow(0.98, state.score - 1)) };
}

function update() {
    if(!gameActive || isPaused || isDying) {
        if(flowGain) flowGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.2);
        return;
    }
    state.frame++;
    if(flowGain && flowFilter) {
        flowGain.gain.setTargetAtTime(0.009 + (input.d * 0.0005), audioCtx.currentTime, 0.1);
        flowFilter.frequency.setTargetAtTime(300 + (input.d * 1500), audioCtx.currentTime, 0.1);
    }
    let nx = player.x + input.x, ny = player.y + input.y, b = 0.2;
    if(maze[Math.floor(player.y)][Math.floor(nx + (input.x > 0 ? b : -b))] === 0) player.x = nx;
    if(maze[Math.floor(ny + (input.y > 0 ? b : -b))][Math.floor(player.x)] === 0) player.y = ny;
    if(state.frame % 5 === 0) trails.push({x: player.x, y: player.y, a: 0.4});
    trails.forEach((t, i) => { t.a -= 0.02; if(t.a <= 0) trails.splice(i,1); });
    keys.forEach(k => { if(k.active && Math.hypot(player.x - k.x, player.y - k.y) < 0.6) { k.active = false; state.keysFound++; playSFX('key'); }});

    if(Math.sin(state.frame * 0.05) > 0) {
        blackHoles.forEach(bh => {
            if(Math.hypot(player.x - bh.x, player.y - bh.y) < 0.6) {
                player.x = 1.5; player.y = 1.5; playSFX('hurt');
            }
        });
    }

    enemy.x += (player.x - enemy.x) * enemy.speed; enemy.y += (player.y - enemy.y) * enemy.speed;
    if(Math.hypot(player.x - enemy.x, player.y - enemy.y) < 0.6) {
        state.hp -= 1.0; 
        document.getElementById('hp').innerText = Math.max(0, Math.ceil(state.hp));
        if(state.frame % 12 === 0) playSFX('hurt');
        if(state.hp <= 0) { 
            isDying = true;
            for(let i=0; i<40; i++) deathParticles.push({x: player.x, y: player.y, vx: (Math.random()-0.5)*0.1, vy: (Math.random()-0.5)*0.1, life: 1.0});
            setTimeout(() => { document.getElementById('death-overlay').style.display = 'flex'; }, 1200);
        }
    }
    if(state.keysFound >= 3 && Math.hypot(player.x - (cols-1.5), player.y - (rows-1.5)) < 0.6) {
        playSFX('complete'); state.score++; state.hp = Math.min(100, state.hp + 20); state.keysFound = 0; buildMap();
    }
}

function drawGameObjects(isMini) {
    const theme = themes[currentThemeIdx] || themes[0];
    const s = isMini ? 0.3 : 1;
    const waveProgress = (Date.now() % 4000) / 4000; 
    const pulse = (Math.sin(state.frame * 0.1) + 1) / 2;

    for(let y=0; y<rows; y++) {
        for(let x=0; x<cols; x++) {
            if(maze[y][x]) {
                ctx.fillStyle = theme.wall;
                ctx.fillRect(x*tile*s, y*tile*s, tile*s, tile*s);
                if(!isMini) {
                    const distFromCenter = Math.hypot(x - cols/2, y - rows/2);
                    const brightness = Math.max(0, 1 - Math.abs(distFromCenter - (waveProgress * Math.hypot(cols/2, rows/2))) / 10);
                    ctx.strokeStyle = theme.accent;
                    ctx.globalAlpha = 0.2 + (brightness * 0.7);
                    ctx.lineWidth = 1.5;
                    ctx.strokeRect(x*tile*s, y*tile*s, tile*s, tile*s);
                    ctx.globalAlpha = 1;
                }
            }
        }
    }

    // --- EXIT GATE BEACON (ALWAYS RENDERED WITH HIGH VISIBILITY) ---
    const gateX = (cols-1.5) * tile * s;
    const gateY = (rows-1.5) * tile * s;
    const gateSize = (tile/1.8) * s;

    if(state.keysFound >= 3) {
        ctx.save();
        // High Intensity Bloom
        ctx.shadowBlur = 40;
        ctx.shadowColor = '#fff';
        
        // Expansion Wave Animation
        const waveSize = ((state.frame * 2) % 150) * s;
        ctx.strokeStyle = `rgba(255, 255, 255, ${1 - (waveSize/(150*s))})`;
        ctx.lineWidth = 3 * s;
        ctx.beginPath();
        ctx.arc(gateX, gateY, waveSize, 0, Math.PI*2);
        ctx.stroke();

        // Core White Square
        ctx.fillStyle = '#fff';
        ctx.fillRect(gateX - gateSize/2, gateY - gateSize/2, gateSize, gateSize);
        
        // Rotating/Pulsing Crosshair
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2 * s;
        ctx.strokeRect(gateX - (gateSize * (1 + pulse*0.5)), gateY - (gateSize * (1 + pulse*0.5)), gateSize*(2 + pulse), gateSize*(2 + pulse));
        ctx.restore();
    } else {
        // Subtle ghost indicator when keys aren't found
        ctx.fillStyle = 'rgba(255,255,255,0.05)';
        ctx.fillRect(gateX - gateSize/2, gateY - gateSize/2, gateSize, gateSize);
    }

    // --- OTHER OBJECTS ---
    blackHoles.forEach(bh => {
        if(!isMini) { ctx.shadowBlur = 15 * pulse; ctx.shadowColor = "#8000ff"; }
        ctx.fillStyle = `rgba(0, 0, 0, ${0.8 + (pulse * 0.2)})`;
        ctx.beginPath(); ctx.arc(bh.x*tile*s, bh.y*tile*s, (tile/2)*s, 0, 7); ctx.fill();
        ctx.strokeStyle = `rgba(128, 0, 255, ${pulse})`;
        ctx.lineWidth = 2; ctx.stroke();
    });
    ctx.shadowBlur = 0;

    keys.forEach(k => { if(k.active) { 
        ctx.shadowBlur = 15; ctx.shadowColor = '#fff';
        ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(k.x*tile*s, k.y*tile*s, (tile/3.5)*s, 0, 7); ctx.fill(); 
    }});
    trails.forEach(t => { ctx.fillStyle = theme.accent; ctx.globalAlpha = t.a; ctx.beginPath(); ctx.arc(t.x*tile*s, t.y*tile*s, (tile/6)*s, 0, 7); ctx.fill(); });
    ctx.globalAlpha = 1; 
    if(!isDying) { 
        ctx.shadowBlur = 20; ctx.shadowColor = theme.accent;
        ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(player.x*tile*s, player.y*tile*s, (tile/4)*s, 0, 7); ctx.fill(); 
    }
    deathParticles.forEach((p, i) => {
        p.x += p.vx; p.y += p.vy; p.life -= 0.02; ctx.fillStyle = theme.accent; ctx.globalAlpha = p.life;
        ctx.fillRect(p.x * tile * s, p.y * tile * s, 4*s, 4*s);
        if(p.life <= 0) deathParticles.splice(i, 1);
    });
    ctx.globalAlpha = 1; 
    ctx.shadowBlur = 15; ctx.shadowColor = '#f00';
    ctx.fillStyle = '#ff4444'; ctx.beginPath(); ctx.arc(enemy.x*tile*s, enemy.y*tile*s, (tile/3)*s, 0, 7); ctx.fill();
    ctx.shadowBlur = 0;
}

function draw() {
    if (isPaused) { requestAnimationFrame(draw); return; }
    const theme = themes[currentThemeIdx] || themes[0];
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = theme.bg; ctx.fillRect(0,0,canvas.width, canvas.height);
    ctx.save();
    if(isDying) {
        cameraZoom = Math.min(cameraZoom + 0.03, 3);
        ctx.translate(canvas.width/2, canvas.height/2); ctx.scale(cameraZoom, cameraZoom);
        ctx.translate(-player.x * tile, -player.y * tile); drawGameObjects(false);
    } else if(isFollowCam) {
        ctx.translate(canvas.width/2, canvas.height/2); ctx.scale(4.5, 4.5);
        ctx.translate(-player.x * tile, -player.y * tile); drawGameObjects(false);
    } else { drawGameObjects(false); }
    ctx.restore();
    
    // --- FOG OF WAR LOGIC ---
    if(gameActive && state.keysFound > 0 && !isDying && !isPaused) {
        ctx.save();
        // Step 1: Restrict view to Player vision circle
        ctx.globalCompositeOperation = 'destination-in';
        let r = state.keysFound === 1 ? 300 : state.keysFound === 2 ? 200 : 120;
        let centerX = isFollowCam ? canvas.width/2 : player.x * tile;
        let centerY = isFollowCam ? canvas.height/2 : player.y * tile;
        
        let grad = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, r);
        grad.addColorStop(0, 'rgba(0,0,0,1)'); 
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grad; 
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Step 2: "BURN" a hole for the exit gate so it bypasses fog
        if(state.keysFound >= 3) {
            let exitX = isFollowCam ? (canvas.width/2 + (cols-1.5 - player.x) * tile * 4.5) : (cols-1.5) * tile;
            let exitY = isFollowCam ? (canvas.height/2 + (rows-1.5 - player.y) * tile * 4.5) : (rows-1.5) * tile;
            
            // This cuts a transparent hole in the fog, letting the white gate underneath shine through
            ctx.globalCompositeOperation = 'destination-out';
            let exitHole = ctx.createRadialGradient(exitX, exitY, 0, exitX, exitY, 200);
            exitHole.addColorStop(0, 'rgba(0,0,0,1)'); 
            exitHole.addColorStop(1, 'rgba(0,0,0,0)'); 
            ctx.fillStyle = exitHole;
            ctx.beginPath(); ctx.arc(exitX, exitY, 200, 0, Math.PI*2); ctx.fill();
        }
        ctx.restore();
    }
    update(); requestAnimationFrame(draw);
}

function quitToMenu() { gameActive = false; isPaused = false; document.getElementById('pause-overlay').style.display = 'none'; document.getElementById('death-overlay').style.display = 'none'; document.getElementById('menu-overlay').style.display = 'flex'; setUIVisibility(false); if(ambGain) ambGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.5); checkSave(); }
function toggleCamera() { isFollowCam = !isFollowCam; document.getElementById('camBtn').innerText = isFollowCam ? "Cam: Follow" : "Cam: Normal"; }
function saveProgress() { localStorage.setItem('neon_specter_phase', state.score); }
function resetProgress() { if(confirm("Format core data?")) { localStorage.removeItem('neon_specter_phase'); location.reload(); }}
function togglePause() { if(!gameActive || isDying) return; isPaused = !isPaused; document.getElementById('pause-overlay').style.display = isPaused ? 'flex' : 'none'; }
function retryLevel() { isDying = false; state.hp = 100; state.keysFound = 0; deathParticles = []; cameraZoom = 1; document.getElementById('death-overlay').style.display = 'none'; buildMap(); }

draw();
</script>
</body>
</html>
